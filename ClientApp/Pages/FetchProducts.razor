@page "/fetchproducts"
@inject HttpClient Http;
@using ClientApp.Models;
@using System.Text.Json;
@using System.Text.Json.Serialization;

<h3>Product List</h3>

<ul>
    @if (products == null)
    {
        <li>Loading...</li>
    }
    else if (products.Length == 0)
    {
        <li>No products available.</li>
    }
    else
    {
        foreach (var product in products)
        {
            <li>@product.Name - $@product.Price</li>
        }
    }
</ul>

@code {
    // Holds the list of products retrieved from the API.
    // Copilot recommended initializing this with Array.Empty to avoid null checks in the UI.
    private Product[]? products;
    
    /// <summary>
    /// Lifecycle method that runs when the component initializes.
    /// Copilot helped structure this method to include:
    /// - Timeout protection using CancellationTokenSource
    /// - Explicit HTTP status validation with EnsureSuccessStatusCode
    /// - Manual JSON deserialization for assignment requirements
    /// - Nested try/catch blocks to handle malformed JSON gracefully
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        // Copilot suggested initializing the array early to ensure the UI always has a safe fallback.
        products = Array.Empty<Product>();

        try
        {
            // Copilot recommended adding a timeout to prevent the UI from hanging on slow API calls.
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));

            // Copilot helped refine the API endpoint call and ensure proper error handling.
            var response = await Http.GetAsync("http://localhost:5212/api/productlist", cts.Token);
            response.EnsureSuccessStatusCode();

            // Copilot suggested reading raw JSON to meet the assignment's requirement for manual deserialization instead of using GetFromJsonAsync.
            var json = await response.Content.ReadAsStringAsync();

            try
            {
                // Copilot recommended enabling case-insensitive matching to ensure the front-end correctly deserializes the back-end's JSON regardless of casing.
                var result = JsonSerializer.Deserialize<ProductResponse>(json, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                });

                // Copilot suggested using the null-coalescing operator to avoid null reference issues.
                products = result?.Products ?? Array.Empty<Product>();
            }
            catch (Exception jsonEx)
            {
                // Copilot recommended logging JSON errors to help diagnose malformed responses.
                Console.WriteLine($"JSON deserialization error: {jsonEx.Message}");
                products = Array.Empty<Product>();
            }
        }
        catch (OperationCanceledException)
        {
            // Copilot suggested catching timeout exceptions separately for clearer debugging.
            Console.Error.WriteLine("API request timed out.");
            products = Array.Empty<Product>();
        }
        catch (Exception ex)
        {
            // Copilot recommended a general catch block to ensure the UI never crashes.
            Console.Error.WriteLine($"Unexpected error: {ex.Message}");
            products = Array.Empty<Product>();
        }
    }
}
